<template>
  <view class="theme-coin-flip">
    <!-- Vault Decorations - Generated by Gemini CLI -->
    <view class="neon-accent-left" />
    <view class="neon-accent-right" />
    <view class="hex-decoration hex-1" />
    <view class="hex-decoration hex-2" />
    <view class="vignette-overlay" />

    <view class="data-stream" v-if="activeTab === 'game'">
      <view
        v-for="i in 10"
        :key="i"
        class="stream-line"
        :style="{
          left: i * 10 + '%',
          animationDuration: 2 + Math.random() * 3 + 's',
          animationDelay: Math.random() * 5 + 's',
        }"
      />
    </view>

    <AppLayout :tabs="navTabs" :active-tab="activeTab" @tab-change="activeTab = $event">
      <!-- Chain Warning - Framework Component -->
      <ChainWarning :title="t('wrongChain')" :message="t('wrongChainMessage')" :button-text="t('switchToNeo')" /><view
        v-if="activeTab === 'game'"
        class="tab-content"
      >
        <!-- Coin Arena -->
        <view class="arena-container">
          <CoinArena
            :display-outcome="displayOutcome"
            :is-flipping="isFlipping"
            :result="result"
            :t="t as (key: string) => string"
          />
        </view>

        <!-- Bet Controls -->
        <view class="controls-container">
          <BetControls
            v-model:choice="choice"
            v-model:betAmount="betAmount"
            :is-flipping="isFlipping"
            :can-bet="canBet"
            :t="t as (key: string) => string"
            @flip="flip"
          />
        </view>

        <!-- Error Message Overlay -->
        <view v-if="errorMessage" class="error-toast">
          <text>{{ errorMessage }}</text>
        </view>

        <!-- Result Modal -->
        <ResultOverlay
          :visible="showWinOverlay"
          :win-amount="winAmount"
          :t="t as (key: string) => string"
          @close="showWinOverlay = false"
        />
      </view>

      <!-- Stats Tab -->
      <view v-if="activeTab === 'stats'" class="tab-content scrollable">
        <NeoCard variant="erobo" class="mb-6">
          <NeoStats :stats="gameStats" />
        </NeoCard>
      </view>

      <!-- Docs Tab -->
      <view v-if="activeTab === 'docs'" class="tab-content scrollable">
        <NeoDoc
          :title="t('title')"
          :subtitle="t('docSubtitle')"
          :description="t('docDescription')"
          :steps="docSteps"
          :features="docFeatures"
        />
      </view>
    </AppLayout>
  </view>
</template>

<script setup lang="ts">
import "../../static/coin-flip.css";
import { ref, computed, onUnmounted } from "vue";
import { useWallet } from "@neo/uniapp-sdk";
import type { WalletSDK } from "@neo/types";
import { formatNumber, sleep, toFixed8 } from "@shared/utils/format";
import { requireNeoChain } from "@shared/utils/chain";
import { sha256Hex, sha256HexFromHex } from "@shared/utils/hash";
import { parseInvokeResult, parseStackItem } from "@shared/utils/neo";
import { useI18n } from "@/composables/useI18n";
import { AppLayout, NeoCard, NeoStats, NeoDoc, NeoButton, type StatItem, ChainWarning } from "@shared/components";
import { audioManager } from "../../utils/audio";
import type { NavTab } from "@shared/components/NavBar.vue";
import { usePaymentFlow } from "@shared/composables/usePaymentFlow";
import { useGameState } from "@shared/composables/useGameState";

import CoinArena, { type GameResult } from "./components/CoinArena.vue";
import BetControls from "./components/BetControls.vue";
import ResultOverlay from "./components/ResultOverlay.vue";

const { t } = useI18n();

const navTabs = computed<NavTab[]>(() => [
  { id: "game", icon: "game", label: t("game") },
  { id: "stats", icon: "chart", label: t("stats") },
  { id: "docs", icon: "book", label: t("docs") },
]);
const activeTab = ref("game");

const docSteps = computed(() => [t("step1"), t("step2"), t("step3"), t("step4")]);
const docFeatures = computed(() => [
  { name: t("feature1Name"), desc: t("feature1Desc") },
  { name: t("feature2Name"), desc: t("feature2Desc") },
]);

const APP_ID = "miniapp-coinflip";
const SCRIPT_NAME = "flip-coin";
const { address, connect, invokeContract, invokeRead, chainType, getContractAddress } = useWallet() as WalletSDK;
const { processPayment, waitForEvent } = usePaymentFlow(APP_ID);

const betAmount = ref("1");
const choice = ref<"heads" | "tails">("heads");
const { wins, losses, winRate, totalGames, recordWin, recordLoss } = useGameState();
const totalWon = ref(0);
const isFlipping = ref(false);
const result = ref<GameResult | null>(null);
const displayOutcome = ref<"heads" | "tails" | null>(null);
const showWinOverlay = ref(false);
const winAmount = ref("0");
const contractAddress = ref<string | null>(null);
const flipScriptHash = ref<string | null>(null);
const errorMessage = ref<string | null>(null);

// Timer tracking for cleanup
let errorClearTimer: ReturnType<typeof setTimeout> | null = null;

const formatNum = (n: number) => formatNumber(n, 2);

const MAX_BET = 100;

const hexToBigInt = (hex: string): bigint => {
  const cleanHex = hex.startsWith("0x") ? hex.slice(2) : hex;
  return BigInt("0x" + cleanHex);
};

const hashSeed = async (seed: string): Promise<string> => {
  const raw = String(seed ?? "").trim();
  const cleaned = raw.replace(/^0x/i, "");
  const isHex = cleaned.length > 0 && /^[0-9a-fA-F]+$/.test(cleaned);
  return isHex ? sha256HexFromHex(cleaned) : sha256Hex(raw);
};

const simulateCoinFlip = async (
  seed: string,
  playerChoice: boolean,
): Promise<{ won: boolean; outcome: "heads" | "tails" }> => {
  const hashHex = await hashSeed(seed);
  const rand = hexToBigInt(hashHex);
  const resultFlip = rand % BigInt(2) === BigInt(0);
  const won = resultFlip === playerChoice;
  const outcome = resultFlip ? "heads" : "tails";
  return { won, outcome };
};

const canBet = computed(() => {
  const n = parseFloat(betAmount.value);
  return n >= 0.05 && n <= MAX_BET;
});

const gameStats = computed<StatItem[]>(() => [
  { label: t("totalGames"), value: wins.value + losses.value },
  { label: t("wins"), value: wins.value, variant: "success" },
  { label: t("losses"), value: losses.value, variant: "danger" },
  { label: t("totalWon"), value: `${formatNum(totalWon.value)} GAS`, variant: "accent" },
]);

const ensureContractAddress = async () => {
  if (!requireNeoChain(chainType, t)) {
    throw new Error(t("wrongChainMessage"));
  }
  if (!contractAddress.value) {
    contractAddress.value = await getContractAddress();
  }
  if (!contractAddress.value) {
    throw new Error(t("contractUnavailable"));
  }
  return contractAddress.value;
};

const ensureScriptHash = async () => {
  if (flipScriptHash.value) return flipScriptHash.value;
  const contract = await ensureContractAddress();
  const info = await invokeRead({ scriptHash: contract, operation: "getFlipScriptInfo" });
  const parsed = parseInvokeResult(info);
  let hash = "";
  if (parsed && typeof parsed === "object" && !Array.isArray(parsed)) {
    hash = String((parsed as Record<string, unknown>).hash ?? "");
  }
  if (!hash) {
    const direct = await invokeRead({
      scriptHash: contract,
      operation: "getScriptHash",
      args: [{ type: "String", value: SCRIPT_NAME }],
    });
    const parsedDirect = parseInvokeResult(direct);
    hash = Array.isArray(parsedDirect) ? String(parsedDirect[0] ?? "") : String(parsedDirect ?? "");
  }
  if (!hash) {
    throw new Error(t("scriptHashMissing"));
  }
  flipScriptHash.value = hash.replace(/^0x/i, "");
  return flipScriptHash.value;
};

const flip = async () => {
  if (isFlipping.value || !canBet.value) return;

  isFlipping.value = true;
  result.value = null;
  displayOutcome.value = null;
  showWinOverlay.value = false;

  try {
    const contract = await ensureContractAddress();

    const amountBase = toFixed8(betAmount.value);
    if (amountBase === "0") {
      throw new Error(t("invalidBetAmount"));
    }

    // Process payment and get invoke function
    const { receiptId, invoke: invokeWithReceipt } = await processPayment(
      betAmount.value,
      `coinflip:${choice.value}:${betAmount.value}`,
    );

    // Initiate bet using the invoke function from payment flow
    const initiateResult = (await invokeWithReceipt("initiateBet", [
      { type: "Hash160", value: address.value as string },
      { type: "Integer", value: amountBase },
      { type: "Boolean", value: choice.value === "heads" },
      { type: "Integer", value: String(receiptId) },
    ])) as { txid: string; receiptId: string };

    const initiateTxid = initiateResult.txid;
    const initiatedEvent = initiateTxid ? await waitForEvent(initiateTxid, "BetInitiated") : null;
    if (!initiatedEvent) {
      throw new Error(t("betPending"));
    }

    const initiatedValues = Array.isArray((initiatedEvent as any)?.state)
      ? (initiatedEvent as any).state.map(parseStackItem)
      : [];
    const betId = String(initiatedValues[1] ?? "");
    const seed = String(initiatedValues[4] ?? "");
    if (!betId || !seed) {
      throw new Error(t("betMissing"));
    }

    audioManager.play("flip");
    const playerChoice = choice.value === "heads";
    const simulated = await simulateCoinFlip(seed, playerChoice);

    displayOutcome.value = simulated.outcome;
    await sleep(400);
    isFlipping.value = false;
    result.value = { won: simulated.won, outcome: simulated.outcome.toUpperCase() };

    if (simulated.won) audioManager.play("win");
    else audioManager.play("lose");

    const scriptHash = await ensureScriptHash();
    const settleTx = await invokeContract({
      scriptHash: contract,
      operation: "settleBet",
      args: [
        { type: "Hash160", value: address.value as string },
        { type: "Integer", value: betId },
        { type: "Boolean", value: simulated.won },
        { type: "ByteArray", value: scriptHash },
      ],
    });

    const settleTxid = String((settleTx as any)?.txid || (settleTx as any)?.txHash || "");
    if (settleTxid) {
      const resolvedEvent = await waitForEvent(settleTxid, "BetResolved");
      if (resolvedEvent) {
        const values = Array.isArray((resolvedEvent as any)?.state)
          ? (resolvedEvent as any).state.map(parseStackItem)
          : [];
        const payoutRaw = values[3];
        const payoutValue = Number(payoutRaw || 0) / 1e8;

        if (simulated.won) {
          recordWin(payoutValue);
          totalWon.value += payoutValue;
          winAmount.value = payoutValue.toFixed(2);
          showWinOverlay.value = true;
        } else {
          recordLoss();
        }
      }
    }
  } catch (e: unknown) {
    errorMessage.value = e?.message || t("error");
    isFlipping.value = false;
    if (errorClearTimer) clearTimeout(errorClearTimer);
    errorClearTimer = setTimeout(() => {
      errorMessage.value = null;
      errorClearTimer = null;
    }, 5000);
  }
};

onUnmounted(() => {
  if (errorClearTimer) {
    clearTimeout(errorClearTimer);
    errorClearTimer = null;
  }
});
</script>

<style lang="scss" scoped>
@use "@shared/styles/tokens.scss" as *;
@use "@shared/styles/variables.scss";
@import "./coin-flip-theme.scss";

.tab-content {
  padding: 20px;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 24px;
  background: var(--bg-primary);
  color: var(--text-primary);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  position: relative;
  z-index: 1;
}

.arena-container {
  width: 100%;
  margin-top: 10px;
}

.controls-container {
  width: 100%;
}

.error-toast {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  background: var(--coin-error-bg);
  color: var(--coin-error-text);
  padding: 12px 24px;
  border-radius: 99px;
  font-weight: 700;
  font-size: 14px;
  backdrop-filter: blur(10px);
  z-index: 3000;
  box-shadow: var(--coin-error-shadow);
  animation: toast-in 0.3s ease-out;
}

@keyframes toast-in {
  from {
    transform: translate(-50%, -20px);
    opacity: 0;
  }
  to {
    transform: translate(-50%, 0);
    opacity: 1;
  }
}

.scrollable {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

:deep(.neo-stats) {
  .stat-card {
    background: var(--coin-stat-bg);
    border: 1px solid var(--coin-stat-border);
  }
  .stat-value {
    font-weight: 900;
    letter-spacing: -1px;
  }
}
</style>
